WordCount
==========
WordCount is a simple and easy to understand algorithm which can be implemented as a mapreduce application. Given a set of text documents, the program counts the number of occurrences of each word. The algorithm consists of three main sections:

    1. Main Program
    2. Mapper
    3. Reducer

An example of Hadoop WordCount is as follows:

.. image:: images/figures/wordcount.png
   :height: 300px
   :width: 520px
   :alt: word count show case
   :align: center

Mapper:

.. code-block:: java
	
    void map(file, text) {
    	foreach word in text.split() {
            output(word, 1);
    	}
    }


The map function emits each word plus an associated count of occurrences (just a "1" is recorded in this pseudo-code). The input document is tokenized, where key is document name and value is document contents.

Reducer:

.. code-block:: java

    void reduce(word, list(count)) {
        output(word, sum(count));
    }

The reduce function sums together all counts emitted for a particular word.

Writing the Mapper Class
-----------------------
The WordCountMapper class is created by extending the Mapper class and the map function is implemented by overriding the map method in the Mapper class. The mapper function takes a key-value pair as an input and outputs a key-value pair as an output (the output is given through the context object). The key value pair that the map function takes as an input and the key value pair given as an output need not be the same type.

For instance, in the WordCountMapper the input to the map method is a key-value pair where the key is the line number and the value is the line of text in the corresponding line (line_number, line_text). It then outputs (word,1) for each word it reads in the line.

.. code-block:: java

    public static class WordCountMapper extends Mapper<Object, Text, Text, IntWritable> {

        private final static IntWritable one = new IntWritable(1);
        private Text word = new Text();

        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
            StringTokenizer itr = new StringTokenizer(value.toString());
            while (itr.hasMoreTokens()) {
                word.set(itr.nextToken());
                context.write(word, one);
            }
        }
    }


Writing the Reducer Class
------------------------

The WordCountReducer class is created by extending the org.apache.hadoop.mapreduce.Reducer class; the reduce method is implemented by overriding the reduce method from the Reducer class. The reduce function collects all the intermediate key-value pairs <word,1>  generated by the multiple map functions. It will then sum up all the occurrences of each word and output a key-value pair for each word in the text document as <word, total_occurrences>. A detailed implementation of the WordCountReducer is shown below.

.. code-block:: java

    public static class WordCountReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
        private IntWritable result = new IntWritable();

        public void reduce(Text key, Iterable<IntWritable> values, Context context)
                throws IOException, InterruptedException {
            int sum = 0;
            for (IntWritable val : values) {
                sum += val.get();
            }
            result.set(sum);
            context.write(key, result);
        }
    }

Writing Main Method
------------------

The main method sets up all necessary configurations and runs the mapreduce job.

    1. Job Name : name of this Job
    2. Executable (Jar) Class: the main executable class. For here, WordCount.
    3. Mapper Class: class which overrides the "map" function. For here, WordCountMapper.
    4. Reducer: class which overrides the "reduce" function. For here , WordCountReducer.
    5. Output Key: type of output key. For here, Text.
    6. Output Value: type of output value. For here, IntWritable.
    7. File Input Path
    8. File Output Path

.. code-block:: java

    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf, "word count");
        job.setJarByClass(WordCount.class);
        job.setMapperClass(WordCountMapper.class);
        job.setCombinerClass(WordCountReducer.class);
        job.setReducerClass(WordCountReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);
        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));
        System.exit(job.waitForCompletion(true) ? 0 : 1);
    }


Complete Code
------------

The complete code of the WordCount example is visible below.

.. code-block:: java

    import java.io.IOException;
    import java.util.StringTokenizer;

    import org.apache.hadoop.conf.Configuration;
    import org.apache.hadoop.fs.Path;
    import org.apache.hadoop.io.IntWritable;
    import org.apache.hadoop.io.Text;
    import org.apache.hadoop.mapreduce.Job;
    import org.apache.hadoop.mapreduce.Mapper;
    import org.apache.hadoop.mapreduce.Reducer;
    import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
    import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

    public class WordCount {

        public static void main(String[] args) throws Exception {
            Configuration conf = new Configuration();
            Job job = Job.getInstance(conf, "word count");
            job.setJarByClass(WordCount.class);
            job.setMapperClass(WordCountMapper.class);
            job.setCombinerClass(WordCountReducer.class);
            job.setReducerClass(WordCountReducer.class);
            job.setOutputKeyClass(Text.class);
            job.setOutputValueClass(IntWritable.class);
            FileInputFormat.addInputPath(job, new Path(args[0]));
            FileOutputFormat.setOutputPath(job, new Path(args[1]));
            System.exit(job.waitForCompletion(true) ? 0 : 1);
        }

        public static class WordCountMapper extends Mapper<Object, Text, Text, IntWritable> {

            private final static IntWritable one = new IntWritable(1);
            private Text word = new Text();

            public void map(Object key, Text value, Context context) throws IOException,
                    InterruptedException {
                StringTokenizer itr = new StringTokenizer(value.toString());
                while (itr.hasMoreTokens()) {
                    word.set(itr.nextToken());
                    context.write(word, one);
                }
            }
        }

        public static class WordCountReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
            private IntWritable result = new IntWritable();

            public void reduce(Text key, Iterable<IntWritable> values, Context context)
                    throws IOException, InterruptedException {
                int sum = 0;
                for (IntWritable val : values) {
                    sum += val.get();
                }
                result.set(sum);
                context.write(key, result);
            }
        }

    }

Compiling the Code
-------------
In order to compile the code we need to create a .java file that contains our code. Execute the following commands and paste the code listed above into the file created by the vim command.

.. code-block:: bash

    cd ~/software/hadoop-2.7.2
    vim WordCount.java

They are several ways to generate a jar file from WordCount.java. The following is a very simple and straightforward method that can be used.  Move to the Hadoop directory and execute the following commands. You need to have the WordCount.java file also under the Hadoop directory.

.. code-block:: bash

    cd ~/software/hadoop-2.7.2
    export HADOOP_CLASSPATH=${JAVA_HOME}/lib/tools.jar
    ./bin/hadoop com.sun.tools.javac.Main WordCount.java
    jar cf wc.jar WordCount*.class


This will create a jar file that contains the compiled classes needed to run the program on Hadoop.

-------
Optional
-------

Another cleaner method would be to create a MVN project for the WordCount example and simply do a “mvn clean install” which will produce a jar file. You will need to add the following dependency in the pom.xml.

.. code-block:: xml

    <dependency>
        <groupId>org.apache.hadoop</groupId>
        <artifactId>hadoop-core</artifactId>
        <version>1.2.1</version>
    </dependency>

Running the Code
--------------

Next we will run the example on distributed mode. Before we do so, we need to create a set of input files that will be given to the program.

First create a directory in which to put all the input files. The program will read all the files that are in this folder. Use the following commands to create the files and directories.

.. code-block:: bash

    mkdir wordcount_input
    cd wordcount_input
    vim 1.txt
    vim 2.txt

Create two text files 1.txt and 2.txt under the folder containing the following:

1.txt - Hello World Bye World

2.txt - Hello Hadoop Goodbye Hadoop

Create a directory on HDFS and copy these two files into HDFS.

.. code-block:: bash

    $HADOOP_HOME/bin/hdfs dfs -mkdir wordcount_input
    $HADOOP_HOME/bin/hdfs dfs -put wordcount_input/* wordcount_input

You can check the files on HDFS using.

.. code-block:: bash

    $HADOOP_HOME/bin/hdfs dfs -ls wordcount_input

To run the mapreduce job execute the following command from the Hadoop directory:

.. code-block:: bash

    $HADOOP_HOME/bin/hadoop jar wc.jar WordCount wordcount_input wordcount_output

After the job has completed, execute the following command and check the output that was generated.

.. code-block:: bash

    $HADOOP_HOME/bin/hdfs dfs -cat wordcount_output/*
    Bye	1
    Goodbye	1
    Hadoop	2
    Hello	2
    World	2


